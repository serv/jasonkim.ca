<html lang="en">
<head>

  <!-- Basic -->
  <meta charset="utf-8">
  <title>Just Enough Ruby To Get By - Jason Kim</title>

  <!-- Mobile -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Styles -->
  <link rel="stylesheet" href="app/bower_components/Skeleton/css/normalize.css">
  <link rel="stylesheet" href="app/bower_components/Skeleton/css/skeleton.css">
  <link rel="stylesheet" href="app/styles/main.css">

  <!-- Favicon -->
  <!-- TODO: Need favicon -->
  <link rel="icon" type="image/png" href="">

</head>
<body>

  <div class="container">
    <div class="row">
      <div class="three columns sidebar">
        <p>Table of Contents</p>
        <ol>
          <li><a href="#overview">Overview</a></li>
          <li><a href="#basic-data-types">Basic Data Types</a></li>
          <li><a href="#expressions-and-statements">Expressions and Statements</a></li>
          <li><a href="#error-handling">Error Handling</a></li>
          <li><a href="#simple-methods">Simple Methods</a></li>
          <li><a href="#iterators">Iterators</a></li>
          <li><a href="#classes">Classes</a></li>
        </ol>
      </div>

      <div class="nine columns content">

        <h1>Just Enough Ruby to Get By</h1>

<p>by Jason Kim (<a href="https://twitter.com/jasoki">@jasoki</a>)</p>

<h2>Plans</h2>

<ul>
<li>Editing continuously to fix errors and bugs</li>
<li>Coding exercises</li>
<li>Meaningful project for the book</li>
</ul>

<h2>About</h2>

<p><em>Just Enough Ruby to Get By</em> will help you begin programming in Ruby.</p>

<p>The book has three main objectives.</p>

<ul>
<li>Introduce important topics in Ruby as quickly as possible</li>
<li>Ramp up problem solving skills to tackle real world problems</li>
<li><del>Dive into to Ruby developer ecosystem and learn to use third party Gems</del></li>
</ul>

<p>The book has two kinds of audiences in mind.</p>

<ul>
<li>Absolute beginners who do not have any programming experience</li>
<li>Experienced programmers who have programmed in other languages such as C, C++ and Java</li>
</ul>

<p>The book isn’t directed aimed at seasoned Ruby programmers. Most of the topics covered by the book will be familiar to programmers who work primarily with Ruby. It might serve a different purpose for Ruby programmers as a refresher.</p>

<p>While the book will cover wide varieties of topics in Ruby language and its ecosystem, it should not be considered as an exhaustive reference. For a thorough reference on Ruby language, please read <a href="http://www.amazon.com/Ruby-Programming-Language-David-Flanagan/dp/0596516177">The Ruby Programming Language</a>.</p>

<p>The book is still in the <strong>beta</strong> stage. It contains errors and the structure of the book will change over time. If you find any error in the book, please report them in the comment section. You may also ask questions in the comment section.</p>

<p>The book is free. Feel free to share it with your friends.</p>

<h2>Table of Contents</h2>

<ol>
<li><a href="#overview">Overview</a></li>
<li><a href="#basic-data-types">Basic Data Types</a></li>
<li><a href="#expressions-and-statements">Expressions and Statements</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#simple-methods">Simple Methods</a></li>
<li><a href="#iterators">Iterators</a></li>
<li><a href="#classes">Classes</a></li>
<li><del>Test Driven Development with RSpec</del></li>
<li><del>Sinatra Web Development</del></li>
</ol>

<h2>1. <a id="overview"></a>Overview</h2>

<ul>
<li>Why Ruby?</li>
<li>Setting Up The Ruby Development Environment

<ul>
<li>Mac OS X</li>
<li>Ubuntu</li>
</ul></li>
<li>Running Your First Ruby Program</li>
</ul>

<h3>Why Ruby?</h3>

<p>There are hundreds of programming languages out there. So why should you program in Ruby?</p>

<p>All programmers have different preferences and styles of programming. Depending on the programmers&#39; values and experiences, programmers can aptly give reasons why they think people should choose a certain programming language. Although programmers may like different languages for different reasons, their opinions are generally correct when identifying why certain programming languages are great for certain uses. This is because programming languages have identifiable characteristics that programmers can point to and compare with one another.</p>

<p>I like to program in Ruby because Ruby is a <em>succinct</em> and is a highly <em>practical</em> language that is <em>widely used</em> by many programmers in the industry.</p>

<p>Ruby codes are succinct and highly readable. This is an opinion that&#39;s sometimes shared among non-Ruby programmers as well. Even with minimal programming experience, you&#39;ll be able to read and understand elementary Ruby codes. In many ways, this characteristic carries over to more complex Ruby codes too. There are some unusual syntaxes that are unique to Ruby, but once you understand what they do, you&#39;ll be able to read and understand complex Ruby code like you&#39;d do with simple Ruby code. Like reading code, writing code feels more straight forward and can even be enjoyable.</p>

<p>Ruby has powerful programming language features that lets you write functional programs with less code. Thousands of developers use <a href="http://rubyonrails.org/">Ruby on Rails</a> to build applications that serve millions of users everyday. Writing code in Ruby will improve your productivity.</p>

<p>Ruby is a popular language. Its popularity has exploded since Ruby on Rails was introduced in 2004. Beginners will have an easier time getting help thanks to the large <a href="http://stackoverflow.com/questions/tagged/ruby">Ruby community on StackOverflow</a>. Your coding skills in Ruby will also be useful for finding a job as a developer as well. There are plenty of companies looking for Ruby developers.</p>

<h3>Setting Up Ruby Development Environment</h3>

<h4>Mac OS X</h4>

<p>Ruby 1.9.3 is currently in wide use. Ruby 2.0.0 was recently released and many are moving towards 2.0.0 now. We will use Ruby version 2.0.0 specifically and we will use <a href="https://rvm.io/">RVM</a> to manage multiple Ruby versions.</p>

<h5>Step 1. Open Terminal</h5>

<p>Let&#39;s search for Terminal using the Spotlight too (Command + Space) and open it. We will be using Terminal often. It will be convenient to keep it in the Dock. Right click on the Terminal in the Dock, Options &gt; Keep in Dock.</p>

<h5>Step 2. Check Ruby Version</h5>

<p>In the terminal run this command to check the current version of Ruby installed on the computer.</p>

<p><code>$ ruby -v</code></p>

<p>The Ruby version is most likely 1.8.7. OS X comes preinstalled with Ruby 1.8.7, but if it is 2.0.0 by any chance, you are off the hook for updates. You can skip the rest of the steps and move onto the next chapter. If your Ruby version is 1.8.7, go to step 3.</p>

<h5>Step 3. Install Git</h5>

<p>Git is a code version control system that Linus Torvalds originally authored. Linus Torvalds is the original creator of Linux. Let’s check if git is installed on your machine.</p>

<p><code>$ git --version</code></p>

<p>If git is installed, the command should be returned with the version of git installed on your machine. If not, <a href="http://git-scm.com/downloads">go to the git website, and download the git installation package for Mac</a>. Install the installation package.</p>

<h5>Step 4. Install Xcode</h5>

<p><a href="https://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;mt=12">Xcode</a> provides a development environment for Mac OS and iOS. It is prudent to install Xcode because many software packages related to software development on Mac has different parts of Xcode as dependancy. Sooner or later, you will be faced with some installation error for some software package that can easily be fixed by installing Xcode. You can <a href="https://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;mt=12">install Xcode through the App Store</a>.</p>

<h5>Step 5. Install RVM</h5>

<p>RVM stands for Ruby Version Manager. There are multiple popular Ruby versions out there and many different Ruby projects use different Ruby versions.</p>

<p><code>$ \curl -L https://get.rvm.io | bash -s stable --ruby</code></p>

<p>Follow the installation guide provided in the RVM website for further customization.</p>

<h4>Ubuntu</h4>

<h5>Step 1: Update Ubuntu</h5>

<p>Run <code>$ sudo apt-get update</code> in the terminal, and enter the password.</p>

<h5>Step 2: Install Git</h5>

<p>To install git, we must install its dependencies.</p>

<p><code>$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev build-essential</code></p>

<p>And we can install git now.</p>

<p><code>$ sudo apt-get install git</code></p>

<h5>Step 3: Install RVM</h5>

<p>We need curl to install RVM.</p>

<p><code>$ sudo apt-get install curl</code></p>

<p>We are ready to install RVM.</p>

<p><code>$ \curl -L https://get.rvm.io | bash -s stable --ruby</code></p>

<p>Installation of RVM and Ruby might take a while. When the installation is finished, close the current Terminal window and open a new one. You can check that Ruby is installed by running the following command:</p>

<p><code>$ ruby -v</code></p>

<h3>Running Your First Ruby Program</h3>

<p>Let&#39;s build our every first program, &quot;Hello World&quot;.</p>

<h4>Interactive Ruby Shell (IRB)</h4>

<p>Interactive Ruby shell, IRB is a shell environment where you can run Ruby code.</p>

<p>Open Terminal and run <code>$ irb</code>. You must have previously installed Ruby in order to use IRB.</p>

<p>Once IRB is launched, run <code>puts &quot;Hello World&quot;</code>.</p>

<p>Notice that the shell prints Hello World.</p>

<h4>Running a Ruby File</h4>

<p>Ruby codes are usually run as files with extension <code>.rb</code>. Create a file called <code>helloworld.rb</code>.</p>

<h5>helloworld.rb</h5>

<pre lang="ruby"><code>puts &quot;Hello World&quot;
</code></pre>

<p>Save the content and in the terminal run <code>$ ruby helloworld.rb</code>.</p>

<p>Notice that the terminal prints Hello World.</p>

<h2>2. <a id="basic-data-types"></a>Basic Data Types</h2>

<p>By and large, programming is manipulating abstractions of data.</p>

<p>Ruby has several built-in ways to represent data. Using these basic building blocks to represent data, you can build more complex data types.</p>

<p>Before we begin, let&#39;s fire up the interactive Ruby shell (IRB) by running <code>$ irb</code> in the terminal. Run all the code yourself to really make the Ruby syntax stick in your head.</p>

<h3>Numbers</h3>

<h4>Integers</h4>

<p>An integer is a sequence of positive whole numbers. All of the following are examples of valid ways to represent integers in Ruby</p>

<pre lang="ruby"><code>12345     # =&gt; 12345
1         # =&gt; 1
1_000_000 # =&gt; 1000000
</code></pre>

<h3>Floats</h3>

<p>There are several ways to write rational numbers in Ruby.</p>

<pre lang="ruby"><code>1.0         # =&gt; 1.0
3.14        # =&gt; 3.14
1e12        # =&gt; 1000000000000.0
</code></pre>

<h3>Strings</h3>

<p>Think of a string as another word for text. String objects are created simply using single quotes, &#39; or double quotes, &quot;.</p>

<pre lang="ruby"><code>&quot;string value&quot;
&#39;this is also a string value&#39;
</code></pre>

<p>You can also insert a variable into a string, and The Ruby interpreter will attempt to convert the variable’s type to the string&#39;s type. This is done by inserting variable in <code>#{variable_name}</code>.</p>

<pre lang="ruby"><code>x = &quot;Kurt&quot;
&quot;#{x} Cobain played with Nirvana.&quot; # =&gt; &quot;Kurt Cobain played with Nirvana.&quot;
</code></pre>

<p>You can also embed ruby code within <code>#{}</code>.</p>

<pre lang="ruby"><code>&quot;3*3 is equal to #{3*3}.&quot; # =&gt; &quot;3*3 is equal to 9.&quot;
</code></pre>

<h3>Arrays</h3>

<p>Arrays store a list of values with unique positions. The unique positions are defined by integers starting from 0 and the unique position is called an <em>index</em>. Arrays are instantiated using square brackets, <code>[]</code> and values are separated by commas, <code>,</code>. Accessing the values stored in an array is done by indicating the index of the value you’d like to access.</p>

<pre lang="ruby"><code>[1]                            # =&gt; [1]
[1, 2, 3]                      # =&gt; [1, 2, 3]
[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]        # =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
g = [5, 6, 7]                  # =&gt; [5, 6, 7]
g[0]                           # =&gt; 5
g[2]                           # =&gt; 7
g[3]                           # =&gt; nil
</code></pre>

<p>Nested arrays are arrays that have other arrays as values.</p>

<pre lang="ruby"><code>n = [[3, 4], [5, 6, 7], [8, 9, 10, 11]]
n[0]                                         # =&gt; [3, 4]
n[2]                                         # =&gt; [8, 9, 10, 11]
n[2][3]                                      # =&gt; 11
</code></pre>

<p>Assigning new values to a preexisting array is done by indicating the index of the new value then assigning the new value into the index of the array.</p>

<pre lang="ruby"><code>inception = [&quot;level 1&quot;, &quot;level 2&quot;, &quot;level 3&quot;]
inception[3] = &quot;limbo&quot;
inception     # =&gt; [&quot;level 1&quot;, &quot;level 2&quot;, &quot;level 3&quot;, &quot;limbo&quot;]
</code></pre>

<p>You can overwrite a value in array as well.</p>

<pre lang="ruby"><code>g = [5, 6, 7]
g[0] = &quot;zero&quot;
g                # =&gt; [&quot;zero&quot;, 6, 7]
</code></pre>

<p>You can concatenate two arrays with <code>+</code>.</p>

<pre lang="ruby"><code>[3, 4] + [5, 6, 7]     # =&gt; [3, 4, 5, 6, 7]
</code></pre>

<h3>Hashes</h3>

<p>A hash is like a dictionary. A dictionary matches every word with a  respective definition, for all entries. Similarly, a hash has a value for every key. Instantiating a hash is done with squiggly brackets, <code>{}</code>.</p>

<pre lang="ruby"><code>h = {}
h[&quot;Vancouver&quot;] = &quot;British Columbia&quot;
h[&quot;Toronto&quot;] = &quot;Ontario&quot;
h[&quot;Montreal&quot;] = &quot;Quebec&quot;
h                # =&gt; {&quot;Vancouver&quot;=&gt;&quot;British Columbia&quot;, &quot;Toronto&quot;=&gt;&quot;Ontario&quot;, &quot;Montreal&quot;=&gt;&quot;Quebec&quot;}
h[&quot;Montreal&quot;]    # =&gt; &quot;Quebec&quot;
</code></pre>

<p>You can assign an array as a value for a key.</p>

<pre lang="ruby"><code>starcraft = {}
starcraft[&quot;Terran&quot;] = [&quot;Marine&quot;, &quot;Medic&quot;, &quot;SCV&quot;]
starcraft[&quot;Zerg&quot;] = [&quot;Zergling&quot;, &quot;Hydrarisk&quot;, &quot;Drone&quot;]
starcraft[&quot;Protoss&quot;] = [&quot;Zealot&quot;, &quot;Dragoon&quot;, &quot;Probe&quot;]
starcraft    # =&gt;  =&gt; {&quot;Terran&quot;=&gt;[&quot;Marine&quot;, &quot;Medic&quot;, &quot;SCV&quot;], &quot;Zerg&quot;=&gt;[&quot;Zergling&quot;, &quot;Hydrarisk&quot;, &quot;Drone&quot;], &quot;Protoss&quot;=&gt;[&quot;Zealot&quot;, &quot;Dragoon&quot;, &quot;Probe&quot;]}
</code></pre>

<p>You can assign multiple key-value pairs at the same time.</p>

<pre lang="ruby"><code>stars = {&quot;Pablo Honey&quot; =&gt; 4, &quot;The Bends&quot; =&gt; 4.5, &quot;OK Computer&quot; =&gt; 5}
</code></pre>

<p>Since Ruby 1.9, you can also use <code>:</code> to replace <code>=&gt;</code>.</p>

<pre lang="ruby"><code>more_stars = {&quot;Kid A&quot;: 5, &quot;Amnesiac&quot;: 4, &quot;Hail to the Cheif&quot;: 4, &quot;In Rainbows&quot;: 3}
</code></pre>

<p>Personally, I like hash rockets (<code>=&gt;</code>) better. Long live hash rockets.</p>

<h3>Ranges</h3>

<p>A range object has a start value, an ending value and a list of values in between. A range starts with a start value, followed by <code>..</code> or <code>…</code>, and finishes with an end value.</p>

<pre lang="ruby"><code>(1..5)  # includes the ending value, 5
(1...5) # does not include the ending value, 5  
</code></pre>

<p>You can use range object on alphabets as well, which makes printing alphabets super easy.</p>

<pre lang="ruby"><code>(&quot;a&quot;..&quot;z&quot;).each {|x| print x }    # prints abcdefghijklmnopqrstuvwxyz
</code></pre>

<p>You can even use ranges with the alphabets of other languages. Here is a list of Korean vowels.</p>

<pre lang="ruby"><code>(&quot;ㅏ&quot;..&quot;ㅣ&quot;).each {|x| print x}  # prints ㅏㅐㅑㅒㅓㅔㅕㅖㅗㅘㅙㅚㅛㅜㅝㅞㅟㅠㅡㅢㅣ
</code></pre>

<h3>Symbols</h3>

<p>Symbols are like string substitutes but they have a few different properties. They often used in Ruby to avoid computationally expensive string comparisons. Symbols are used usually as keys in hashes. Symbols start with <code>:</code> followed by some symbol name.</p>

<p>If you have a code where you are using strings as identifiers for something, consider using symbols instead. For example, if you have two strings, <code>&quot;male&quot;</code> and <code>&quot;female&quot;</code> as identifiers for gender, use <code>:male</code> and <code>:female</code> to identify a person’s gender instead.</p>

<p>You can covert from string to symbol and symbol to string easily using either the <code>to_sym</code> to convert from a string to a symbol and <code>to_s</code> to convert from a symbol to a string.</p>

<pre lang="ruby"><code>“string_to_symbol”.to_sym # =&gt; :string_to_symbol
“string to symbol”.to_sym # =&gt; :”string to symbol”
symbol_to_string.to_s     # =&gt; “symbol_to_string”
</code></pre>

<h3>Boolean</h3>

<p>There are only two Boolean values, <code>true</code> and <code>false</code>. <code>nil</code> in Ruby indicates the absence of value. In other programming languages such as JavaScript, <code>null</code> is the comparable keyword to <code>nil</code> in Ruby.</p>

<h2><a id="expressions-and-statements"></a>3. Expressions and Statements</h2>

<p>Simply storing data as different data types isn&#39;t all that fun. In order to do anything even remotely interesting, you need to know a bit about expressions and statements in Ruby.</p>

<h3>Variables and Constants</h3>

<p>Variables are created to store values.</p>

<pre lang="ruby"><code>a = &quot;a&quot;
a = 1
a = [&quot;cat&quot;, &quot;dog&quot;]
</code></pre>

<p>Note that variables in Ruby are <em>dynamically typed</em>. As a result, a Ruby variable can store values of different types. <em>Statically typed</em> language such as Java does not allows this.</p>

<p>There are different kinds of variables. Variables beginning with:</p>

<ul>
<li><code>$</code>: global variables are available everywhere in a program.</li>
<li><code>@</code>: instance variables</li>
<li><code>@@</code>: class variables</li>
</ul>

<p>Instance variables and class variables will be explained in <strong>Chapter 7. Classes</strong>.</p>

<p>Constants are like variables, but their values doesn&#39;t change. Constants look like <code>THIS_IS_A_CONSTANT</code>. If you are referring to a constant in a module or a class, it looks like <code>ModuleName::SOME_CONSTANT</code> and <code>ClassName::ANOTHER_CONSTANT</code>.</p>

<p>Assigning value to a variable or a constant is done with the <code>=</code> operator. The value on the right hand side is assigned to the variable on the left hand side.</p>

<h3>Calling Methods</h3>

<p>In programming, methods are used to manipulates data. In order to <em>call</em> or <em>execute</em> a method, Ruby uses the <code>.</code> operator.</p>

<ul>
<li>Calling class method: <code>SomeClass.method_name</code></li>
<li>Calling instance method: <code>some_instance.method_name</code></li>
</ul>

<h4>Daisy-chain</h4>

<p>Ruby allows multiple methods to be called on a method in a sequence. This is called <em>daisy-chaining</em> and it looks something like <code>some_method.some_other_method.another_method</code>.</p>

<h3>Arithmetics</h3>

<p>The four cardinal mathematical operations are done the same way.</p>

<pre lang="ruby"><code>5 + 5    # =&gt; 10
5 - 5    # =&gt; 0
5 * 5    # =&gt; 25
5 / 5    # =&gt; 1
</code></pre>

<p>Modulo operations that retrieve the remainder after division is done with the operator <code>%</code>.</p>

<pre lang="ruby"><code>17 % 5     # =&gt; 2
</code></pre>

<p>Exponential operations are done using <code>**</code>.</p>

<pre lang="ruby"><code>2 ** 3     # =&gt; 8
</code></pre>

<h3>Boolean Comparisons</h3>

<p>Boolean operations are operations that result in either <code>true</code> or <code>false</code>.</p>

<ul>
<li>less than <code>&lt;</code></li>
<li>less than or equal to <code>&lt;=</code></li>
<li>greater than <code>&gt;</code></li>
<li>greater than or equal to <code>&gt;=</code></li>
<li>equal to <code>==</code></li>
<li>not equal to <code>!=</code></li>
</ul>

<h3>Boolean Operators</h3>

<p>We can incorporate multiple boolean statements with boolean operators.</p>

<ul>
<li>And: <code>&amp;&amp;</code></li>
<li>Or: <code>||</code></li>
<li>Not: <code>!</code></li>
</ul>

<p>You can perform large boolean operations with Ruby.</p>

<pre lang="ruby"><code>((5 &gt; 2) &amp;&amp; (4 &gt;= 5)) || (2*3 &lt; 7)    # =&gt; true
</code></pre>

<p>In order to see how this is <code>true</code>, perform individual comparisons first.</p>

<pre><code>  ((5 &gt; 2) &amp;&amp; (4 &gt;= 5)) || (2*3 &lt; 7)
= (true &amp;&amp; false) || true
= false || true
= true
</code></pre>

<h3>Conditionals</h3>

<p>Computers are dumb. You have to explicitly tell them when to run different pieces of code. For such occasions we use conditional statements to divide up when different pieces of code will be run.</p>

<h4>If</h4>

<p><code>if</code> is the most commonly found conditional.</p>

<pre lang="ruby"><code>if some_contional_expression
  code_to_execute
end
</code></pre>

<p>Ruby programmer also frequently use this one liner as well.</p>

<pre lang="ruby"><code>code_to_execute if some_contional_expression
</code></pre>

<p><code>code_to_execute</code> will only run if <code>some_contional_expression</code> evaluates to <code>true</code>.</p>

<h4>Else</h4>

<p><code>else</code> can be tagged after an <code>if</code> statement like below.</p>

<pre lang="ruby"><code>if some_contional_expression
  code_to_execute
else
  some_other_code_to_execute
end
</code></pre>

<p>Again, there is one linear short cut for if-else statement.</p>

<pre lang="ruby"><code>some_contional_expression ? code_to_execute_if_true : code_to_execute_if_false
</code></pre>

<p>First, whether or not <code>some_contional_expression</code> will return <code>true</code> or <code>false</code> is determined. If <code>true</code> is returned, <code>code_to_execute_if_true</code> is executed. If <code>false</code> is returned, <code>code_to_execute_if_false</code> is executed.</p>

<h4>Else if</h4>

<p>In many situations, not all conditional statements take the form of either-or statements. You may need multiple conditional expressions to construct a full conditional statement. In such scenarios, you can use <code>elsif</code></p>

<pre lang="ruby"><code>if conditional_a
  run_a
elsif conditional_b
  run_b
elsif conditional_c
  run_c
elsif conditional_d
  run_d
else
  run_anything_else
end
</code></pre>

<p>You can incorporate <code>else</code> after all other <code>elsif</code> expressions.</p>

<h4>Case</h4>

<p>Some large if-elsif-else conditional statements can be simplified.</p>

<pre lang="ruby"><code># Woody Allen movies
if movie == &quot;Annie Hall&quot;
  4
elsif movie == &quot;Manhatten&quot;
  3.5
elsif movie == &quot;Zelig&quot;
  3
elsif movie == &quot;Midnight in Paris&quot;
  2.5
else
  2
end
</code></pre>

<p>Are you sick of typing <code>movie ==</code> in every conditional expression? I am too. In this kind of situation, a <code>case</code> statement can be used. The above example can be re-written as shown below.</p>

<pre lang="ruby"><code>case movie
when &quot;Annie Hall&quot;
  4
when &quot;Manhatten&quot;
  3.5
when &quot;Zelig&quot;
  3
when &quot;Midnight in Paris&quot;
  2.5
else
  2
end
</code></pre>

<h3>Loops</h3>

<p>Computers are great at doing mindlessly boring tasks repeatedly. You can take advantage of this ability computers have by using <code>while</code> and <code>for</code> in Ruby.</p>

<h4>While</h4>

<p>A <code>while</code> loop runs as long as a given condition is true.</p>

<pre lang="ruby"><code># this loop will run until n reaches 10
n = 0
while n &lt; 10
  puts n
  n += 1
end
</code></pre>

<h4>For</h4>

<p>A <code>for</code> loop runs until it reaches a certain condition while performing an action with each iteration.</p>

<pre lang="ruby"><code>for i in 0..9
  puts i
end
</code></pre>

<p>This time we don&#39;t need to do <code>n += 1</code> because <code>for</code> loop will iterate through 0 to 9 for us.</p>

<h4>Commentary on While and For loops</h4>

<p>While loops and for loops are not commonly used in Ruby. This might sound shocking if you are coming from C, C++ or a Java background, but Ruby programmers usually use to <em>blocks</em> to handle iterating through enumerable objects. We will encounter blocks in <em>Chapter 5. Simple Methods</em>.</p>

<h2><a id="error-handling"></a>4. Error Handling</h2>

<p>Programs are prone to have errors and bugs. They are an inevitable part of programming. Errors are caused by many reasons. Errors usually arise because of by mistakes in the code, but sometimes the error might not be your code&#39;s fault. For example, if your application has to make an API call to a third party application and the error could be the third party application failing. A good programmer knows what kind of code will be more error prone than others. To account for the risk, he can preemptively write code defensively to enable his program to <em>handle</em> errors. Errors are also commonly referred to as <em>exceptions</em>.</p>

<p>When an error occurs while a program is running, we say that an exception is <em>raised</em> or <em>thrown</em>. By default, a Ruby program will terminate when an exception is raised, but this is not usually desirable. Thankfully, you can use <em>exception handlers</em> to avoid unwanted program termination. The <code>raise</code> keyword is used to raise an exception and the <code>rescue</code> keyword handles an exception.</p>

<pre lang="ruby"><code>def whats_your_age(age)
  raise &quot;wrong argument&quot; if age &lt; 0
  puts &quot;You are #{age}&quot;
end
</code></pre>

<p>The example method shown above uses <code>age</code> as an argument. If the argument is a negative number, the program raises a &quot;nil argument&quot; exception. If the exception type is not specified, Ruby treats the exception of <code>RuntimeError</code> type. However, there are many other types of exceptions that can be raised instead.</p>

<h3>Types of Exceptions</h3>

<ul>
<li>NoMemoryError</li>
<li>ScriptError

<ul>
<li>LoadError</li>
<li>NotImplementedError</li>
<li>SyntaxError</li>
</ul></li>
<li>SignalException

<ul>
<li>Interrupt</li>
</ul></li>
<li>StandardError -- default for rescue

<ul>
<li>ArgumentError</li>
<li>IndexError

<ul>
<li>StopIteration</li>
</ul></li>
<li>IOError

<ul>
<li>EOFError</li>
</ul></li>
<li>LocalJumpError</li>
<li>NameError

<ul>
<li>NoMethodError</li>
</ul></li>
<li>RangeError

<ul>
<li>FloatDomainError</li>
</ul></li>
<li>RegexpError</li>
<li>RuntimeError -- default for raise</li>
<li>SecurityError</li>
<li>SystemCallError

<ul>
<li>Errno::*</li>
</ul></li>
<li>SystemStackError</li>
<li>ThreadError</li>
<li>TypeError</li>
<li>ZeroDivisionError</li>
</ul></li>
<li>SystemExit</li>
<li>fatal – impossible to rescue</li>
</ul>

<p>It is more suitable to raise the exception as a type of <code>ArgumentError</code> instead of <code>RuntimeError</code> in the example above. The code below raises a <code>ArgumentError</code> exception.</p>

<pre lang="ruby"><code>def whats_your_age(age)
  raise ArgumentError, &quot;wrong argument&quot; if age &lt; 0
  puts &quot;You are #{age}&quot;
end
</code></pre>

<h3>Common Usage of <code>rescue</code> and <code>begin</code></h3>

<p>A <code>rescue</code> keyword commonly used with <code>begin</code> keyword. A <code>rescue</code> keyword appears after lines of code for a <code>begin</code> section. If an exception is raised in the <code>begin</code> section of the code, the <code>rescue</code> section of the code will come to <em>rescue</em>.</p>

<pre lang="ruby"><code>begin
  # begin section of the code
rescue
  # rescue section of the code
end
</code></pre>

<p>You can create an exception object and store it in a variable. This exception object will become available in the rescue section of the code. The example below prints the exception message to console.</p>

<pre lang="ruby"><code>begin
  whats_your_age(-2)
rescue =&gt; exception_variable
  puts exception_variable.message
end
</code></pre>

<h4><code>rescue</code> Based On Exception Type</h4>

<p>Up until now, we&#39;ve been assuming that there is only one way to handle an exception. However, there are cases where we want to handle different exceptions differently. Ruby allows use of multiple rescue sections to handle exceptions of different types raised in the <code>begin</code> section of the code.</p>

<p>Let&#39;s consider the <code>whats_your_age</code> method that we wrote earlier.</p>

<pre lang="ruby"><code>def whats_your_age(age)
  raise ArgumentError, &quot;wrong argument&quot; if age &lt; 0
  puts &quot;You are #{age}&quot;
end
</code></pre>

<p>This method wasn&#39;t written to handle an exception when a string is used as an argument. Let&#39;s raise an exception when a string is used as an argument.</p>

<pre lang="ruby"><code>def whats_your_age(age)
  raise ArgumentError, &quot;wrong argument&quot; if age &lt; 0
  raise TypeError, &quot;wrong type argument&quot; if age.is_a?(String)
  puts &quot;You are #{age}&quot;
end
</code></pre>

<p><code>whats_your_age(-2)</code> will raise an <code>ArgumentError</code> exception and <code>whats_your_age(&quot;minus two&quot;)</code> will raise a <code>TypeError</code> exception.</p>

<p>Ruby can handle two different exceptions by creating two <code>rescue</code> sections for each exception.</p>

<pre lang="ruby"><code>begin
  `whats_your_age(&quot;minus two&quot;)`
rescue ArgumentError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;negative number as age?&quot;
rescue TypeError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;i can&#39;t read english. speak in numbers.&quot;
end
</code></pre>

<p>If you want to handle the rest of the exceptions differently, you can use <code>else</code>.</p>

<pre lang="ruby"><code>begin
  `whats_your_age(&quot;minus two&quot;)`
rescue ArgumentError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;negative number as age?&quot;
rescue TypeError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;i can&#39;t read english. speak in numbers.&quot;
else
  puts &quot;gotta catch &#39;em all!&quot;
end
</code></pre>

<p>If you want to <em>ensure</em> that a certain code runs no matter what happens, you can use the <code>ensure</code> keyword.</p>

<pre lang="ruby"><code>begin
  `whats_your_age(&quot;minus two&quot;)`
rescue ArgumentError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;negative number as age?&quot;
rescue TypeError =&gt; exception_variable
  puts exception_variable.message
  puts &quot;i can&#39;t read english. speak in numbers.&quot;
else
  puts &quot;gotta catch &#39;em all!&quot;
ensure
  puts &quot;this will be printed for sure.&quot;
end
</code></pre>

<h2><a id="simple-methods"></a>5. Simple Methods</h2>

<p>A <em>method</em> is a chunk of code that you can use by invoking its name and appropriate input on an object. The last value evaluated in the method becomes the value of the invoked method. The value of the invoked method is referred to as the <em>return</em> value.</p>

<h3>Defining Methods</h3>

<p>A method consists of 4 parts.</p>

<pre lang="ruby"><code>def method_name(argument1, argument2)
  body_of_code
end
</code></pre>

<ol>
<li>A <code>def</code> keyword that appears at the beginning of every method. An <code>end</code> appears at the end of every method.</li>
<li>A <em>method name</em> comes right after the <code>def</code> keyword.</li>
<li>Arguments for a method that will be used to evaluate the return value of the method.</li>
<li>The body of code in the method determines the return value of the method.</li>
</ol>

<h3>Terminating Methods</h3>

<p>Methods will terminate when an exception is raised or when a value is returned. Methods can return a value in the middle of the method by using <code>return</code> keyword and terminate the method prematurely. Methods don&#39;t necessarily need to have a <code>return</code> keyword. When methods don&#39;t have a <code>return</code> keyword, they will run until the end of the body of the method. The value evaluated in the method will become the return value of the method.</p>

<p><img src="http://upload.wikimedia.org/math/5/1/4/5147eb43c4acd2e51619a89152c79ac1.png" alt="Diagram for Arithmatic Sum Equation"></p>

<pre lang="ruby"><code>def arithmatic_sum(n)
  if n &lt; 0
    raise ArgumentError, &quot;argument must be greater than 0.&quot;
  elsif !n.is_a?(Integer)
    raise TypeError, &quot;argument must be an integer&quot;
  else
    n*(n+1)/2
  end
end
</code></pre>

<p>In <code>arthmatic_sum</code> method, we see three ways in which the method can end.</p>

<ol>
<li>If the method takes a negative number as the method&#39;s argument, the method raises an ArgumentError exception and terminates the method.</li>
<li>If the method takes a non-integer number as the method&#39;s argument, the method raises a TypeError exception and terminates the method.</li>
<li>If the argument is a positive integer, the method will evaluate <code>n*(n+1)/2</code> and return the value.</li>
</ol>

<h3>Method Invocations</h3>

<p>Methods are always called on an object.</p>

<pre lang="ruby"><code>x = 2
x.minus(2) #=&gt; 0

def minus(n)
  self - n
end
</code></pre>

<p><code>self</code> refers to the object that method is invoked on. In this case, <code>self</code> refers to <code>x</code>.</p>

<p>A typical method invocation consists of 3 parts.</p>

<pre lang="ruby"><code>some_object.method_name(argument)
</code></pre>

<ol>
<li>An object on which the method is called on.</li>
<li><code>.</code> which demarcates the object and the method name</li>
<li>The method with its name and appropriate arguments</li>
</ol>

<h3>Conventions Around Ruby Methods</h3>

<p>Although many of these rules are not explicitly enforced by the Ruby interpreter, programmers themselves have developed programming conventions regarding how Ruby methods are named.</p>

<ul>
<li>All alphabets are lower case.</li>
</ul>

<pre lang="ruby"><code>def lowercased_method_name
end
</code></pre>

<ul>
<li>Use <em>camel case</em> to indicate multiple number of words in the method name.</li>
</ul>

<pre lang="ruby"><code># use this
def something_with_multiple_words
end

# rather than this
def somethingWithMultipleWords
end
</code></pre>

<ul>
<li>Method names that end with <code>=</code> are <em>setter</em> methods. Setter methods are often used to set the value of an object or an attribute of an object.</li>
</ul>

<pre lang="ruby"><code>def set_height_in_cm=(value)
  self.height_in_cm = &quot;#{value} cm&quot;
end
</code></pre>

<ul>
<li>Method names that end with <code>?</code> are methods that have a boolean return value.</li>
</ul>

<pre lang="ruby"><code>def did_you_pass?(average)
  average &gt; 59.5
end
</code></pre>

<ul>
<li>Method names that end with a <code>!</code> are mutators. Mutators alter the object that the method is called on. In the example below, notice how <code>sort</code> doesn&#39;t alter <code>a</code>, but calling <code>sort!</code> does alter <code>a</code>.</li>
</ul>

<pre lang="ruby"><code>a = [7, 3, 5, 4, 9, 8, 1, 6, 2, 0]
a.sort     # =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a          # =&gt; [7, 3, 5, 4, 9, 8, 1, 6, 2, 0]
a.sort!    # =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
a          # =&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</code></pre>

<ul>
<li>Ruby operators such as <code>*</code>, <code>-</code>, and <code>+</code> can also be used as method names. These are called <code>operator methods</code>.</li>
</ul>

<pre lang="ruby"><code>def +(points)
  self.score += points
end

def -(points)
  self.score -= points
end
</code></pre>

<ul>
<li>Parentheses are optional when methods are called. However, parentheses must be used when method invocation becomes ambiguous.</li>
</ul>

<pre lang="ruby"><code># both are allowed
puts arithmatic_sum(10) # preferred
puts arithmatic_sum 10
</code></pre>

<h3>Method Arguments</h3>

<h4>Default Values</h4>

<p>Ruby allows you to have variables with a default value. If the method is called without setting a value in the default value parameter, the default value is used. If the method is called with a new value in the default value parameter, the variable is assigned the new value instead of the default value.</p>

<pre lang="ruby"><code>def male_title(name, prefix = &quot;Mr.&quot;)
  prefix + &#39; &#39; + name
end

male_title(&quot;Malkovich&quot;)  # =&gt; &quot;Mr. Malkovich&quot;

male_title(&quot;Who&quot;, &quot;Dr.&quot;) # =&gt; &quot;Dr. Who&quot;
</code></pre>

<h4>Dealing With A Varying Number of Arguments For A Method</h4>

<p>Some methods may not have a definitive number of arguments. To deal with this, use a <code>*</code> operator in front of the argument name, when you define a method. This denotes that the method may take a varying number of arguments.</p>

<pre lang="ruby"><code>def connect(first, *rest)
  first + rest.join(&#39;&#39;)
end

connect(&quot;a&quot;)                        # =&gt; &quot;a&quot;
connect(&quot;a&quot;, &quot;b&quot;)                   # =&gt; &quot;ab&quot;
connect(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)    # =&gt; &quot;abcde&quot;
</code></pre>

<p>If the argument name doesn&#39;t start with an <code>*</code>, that means that you must insert a value for that argument when you call the method.</p>

<pre lang="ruby"><code>connect    # ArgumentError: wrong number of arguments (0 for 1+)
</code></pre>

<p>You can pass an array into methods that have an <code>*</code> before the variable name in the paramter.</p>

<pre lang="ruby"><code>array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]
connect(*array)    #=&gt; &quot;abcde&quot;
</code></pre>

<p>Note that <code>connect(array)</code> and <code>connect(*array)</code> are not the same. The <code>connect(array)</code> case considers <code>first = array</code> and <code>rest = nil</code>. <code>connect(*array)</code> case considers <code>first = &quot;a&quot;</code> and <code>rest = [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]</code>.</p>

<h4>Hashes As Arguments</h4>

<p>As the number of arguments for a method increase, it becomes more difficult to remember the order of the arguments when you call the method. You may use hashes as arguments for methods. This avoids the need for remembering the exact order of methods&#39; arguments.</p>

<pre lang="ruby"><code>def allow_hash(hash)
  hash[:a] + hash[:b]
end

allow_hash({:a =&gt; 1, :b =&gt; 2})      # =&gt; 3
</code></pre>

<p>You can omit <code>{}</code> surrounding the keys and values for the hash argument if the hash is the last argument of the method.</p>

<pre lang="ruby"><code>allow_hash(:a =&gt; 1, :b =&gt; 2)        # =&gt; 3
</code></pre>

<h2><a id="iterators"></a>6. Iterators</h2>

<p>If you have made it this far in the book, congratulations! You are one step closer to becoming a productive Ruby programmer. In this chapter, we will learn to use <em>iterators</em>. If you have anything you need to iterate multiple times in Ruby, consider using iterators first. Iterators are so commonly used in Ruby that, <code>while</code> and <code>for</code> which frequently appear in C, C++ and Java code for iterations are almost never used in Ruby. Yikihiro Matsumoto (the creator of Ruby) and David Flanagan (author of <em>JavaScript: The Definitive Guide</em>) stated that &quot;Iterators are one of the most noteworthy features of Ruby …&quot; in the <em>The Ruby Programming Language</em>. Iterators might seem weird at first, but once you understand the syntax, using iterators will become just easy as any other code.</p>

<h3>Iterators In Action</h3>

<p>Before we dive into learning about the specifics of iterators, let&#39;s see some examples of iterators.</p>

<pre lang="ruby"><code># NASA countdown
10.downto(0) do |k|
  if k != 0
    puts k
  else
    puts &quot;0\nLift off!&quot;
  end
end
</code></pre>

<p>This code will print the following in the console.</p>

<pre lang="ruby"><code>10
9
8
7
6
5
4
3
2
1
0
Lift off!
</code></pre>

<p><code>downto</code> is a iterator method that is applied to <code>10</code> and accepts <code>0</code> as an argument. The iterator is followed by a chunk of code called <em>block</em>. The code inside the block is evaluated at each iteration. Let&#39;s see a few more examples.</p>

<pre lang="ruby"><code>3.times {|t| puts &quot;Three times the charm&quot; }

members = [&quot;Adam&quot;, &quot;Bob&quot;, &quot;Claire&quot;]
# Greet members
members.each {|member| puts &quot;Hello #{member}&quot; }

# Get the length of the member&#39;s name
members.map {|member| member.length } # =&gt; [4, 3, 6]
</code></pre>

<h3>Iterator-Block Combination</h3>

<p>Iterators look different from other pieces of code we&#39;ve seen so far. To unfamiliar eyes, they look complicated. However, once you understand the syntax of blocks, they are easy to implement.</p>

<pre lang="ruby"><code>object_to_iterate.iterator_method(arguments) do |parameter1, parameter2|
  # body of block
end
</code></pre>

<ol>
<li>Iterator methods and blocks go hand in hand. A block appears after an iterator method.</li>
<li>An object to iterate (<code>object_to_iterate</code>) is always stated before an iterator method (<code>iterator_method</code>).</li>
<li>Iterator methods may or may not have arguments.</li>
<li>Blocks start with <code>do</code> and end with <code>end</code>. If the iterator-block code is written in a single line, you should use <code>{</code> and <code>}</code> by convention.</li>
<li>Blocks may contain parameters like methods.</li>
<li>The body of block is evaluated in every iteration.</li>
</ol>

<h3>Common Iterators</h3>

<p>Here are some common methods you can apply to collections to get you started.</p>

<h4><code>each</code></h4>

<p>Executes block and returns the list of objects without mutating</p>

<ul>
<li>prints 246810 and returns 1, 2, 3, 4, 5</li>
</ul>

<pre lang="ruby"><code>[1, 2, 3, 4, 5].each {|x| print x*2 }
</code></pre>

<ul>
<li>prints artists’ name and their nationality and returns the hash itself</li>
</ul>

<pre lang="ruby"><code>celebs = {&quot;Justin Bieber&quot; =&gt; &quot;Canadian&quot;,
  &quot;Psy&quot; =&gt; &quot;Korean&quot;,
  &quot;Nicki Minaj&quot; =&gt; &quot;American&quot;}
celebs.each {|key, value| puts &quot;#{key}: #{value}&quot; }
</code></pre>

<h4><code>each_with_index</code></h4>

<p>Almost like <code>for</code> loop with index. The index begins from 0.</p>

<ul>
<li>prints table of contents to the console.</li>
</ul>

<pre lang="ruby"><code>contents = [&quot;Overview&quot;,
  &quot;Basic Data Types&quot;,
  &quot;Expressions and Statements&quot;,
  &quot;Error Handling&quot;,
  &quot;Simple Methods&quot;,
  &quot;Iterators&quot;,
  &quot;Classes&quot;,
  &quot;Test Driven Development with RSpec&quot;,
  &quot;Sinatra Web Development&quot;]

contents.each_with_index do |content, index|
  puts &quot;#{index+1}. #{content}&quot;
end
</code></pre>

<h4><code>map</code></h4>

<p>Executes block and returns the list of mutated objects</p>

<ul>
<li>returns 2, 4, 6, 8, 10</li>
</ul>

<pre lang="ruby"><code>[1, 2, 3, 4, 5].map {|x| x*2 }
</code></pre>

<h4><code>select</code></h4>

<p>Returns a list of objects when condition is true</p>

<ul>
<li>returns 2</li>
</ul>

<pre lang="ruby"><code>[1, 2, 3, 4, 5].select {|x| x==2 }
</code></pre>

<h4><code>reject</code></h4>

<p>Returns a list of objects when condition is false</p>

<ul>
<li>returns 1, 3, 4, 5</li>
</ul>

<pre lang="ruby"><code>[1, 2, 3, 4, 5].reject {|x| x==2 }
</code></pre>

<h4><code>partition</code></h4>

<p>Create two collections. First collection for true, second for false.</p>

<ul>
<li>returns 4, 5, 1, 6</li>
</ul>

<pre lang="ruby"><code>[1, 4, 5, 6].partition {|x| x==4 || x==5 }
</code></pre>

<h4><code>upto</code></h4>

<p>Numeric iterator that increases index by one each iteration.</p>

<ul>
<li>determine arithmetic sum</li>
</ul>

<pre lang="ruby"><code>sum = 0
0.upto(100) {|index| sum += index }
sum # =&gt; 5050
</code></pre>

<h4><code>downto</code></h4>

<p>Numeric iterator that decreases index by one each iteration.</p>

<ul>
<li>countdown</li>
</ul>

<pre lang="ruby"><code>10.downto(0) {|index| puts index }
</code></pre>

<h4><code>times</code></h4>

<p>Numeric iterator that iterates a given number of times.</p>

<ul>
<li>print &quot;something&quot; 5 times</li>
</ul>

<pre lang="ruby"><code>5.times {|x| puts &quot;something&quot; }
</code></pre>

<h4><code>inject</code></h4>

<p>Has two block parameters. First parameter contains the accumulated value from the previous iteration.</p>

<ul>
<li>arithmetic sum 2</li>
</ul>

<pre lang="ruby"><code>one_to_ten = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
sum = one_to_ten.inject do |sum, element|
  sum += element
end
sum # =&gt; 55
</code></pre>

<ul>
<li>arithmetic sum 3 using an argument on inject</li>
</ul>

<pre lang="ruby"><code>one_to_ten = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
sum2 = one_to_ten.inject(10) do |sum, element|
  sum += element
end
sum2 # =&gt; 65, 10 is added
</code></pre>

<h3>Custom Iterators</h3>

<p>We can create custom iterators by using a <code>yield</code> statement. <code>yield</code> lends the value to the block.</p>

<pre lang="ruby"><code>class Integer
  def get_randoms_in(max)
    self.times {|x| yield rand(max) }
  end
end

#
5.get_randoms_in(10) {|x| puts x }
</code></pre>

<p>The code above prints the following:</p>

<pre lang="ruby"><code>9
6
4
4
6
</code></pre>

<p><code>get_randoms_in</code> is a custom iterator. The method uses an iterator, <code>times</code>. During each iteration, the <code>yield</code> statement lends the evaluated value from <code>rand(max)</code> to the block that comes after <code>get_randoms_in</code>. The <code>rand(max)</code> code returns a random integer between 0 and <code>max</code>. In the block that comes after <code>get_randoms_in</code>, the random number is printed to console.</p>

<p>We have the <code>get_randoms_in</code> method wrapped in an <code>Integer</code> class. This is because we wanted to call <code>get_randoms_in</code> method on an integer object such as <code>5</code>. We will learn more about <code>class</code> in the next chapter.</p>

<h2><a id="classes"></a>7. Classes</h2>

<p>Object oriented programming (OOP) is a programming style that roughly revolves around manipulating abstraction called <em>objects</em>. OOP remains as the dominant programming paradigm currently. There are a handful of other programming styles that some programmers actively use, but none have enjoyed the popularity commanded by object oriented programming.</p>

<p><em>Classes</em> are abstractions of common objects. <em>Objects</em> refer to specific instances of classes. What does all these jargon mean anyway? Consider the diagram below. <code>Car</code> is a class. The car class is a generalization of car <em>instances</em> such as Honda Civic, Toyata Corolla and Volkswagen Jetta.</p>

<p><img src="http://i.imgur.com/VWDFnV1.png" alt="enter image description here"></p>

<p>A class may have <em>attributes</em>. Attributes are common characteristics of instances of a class. A car has a name and a brand. It is priced at a certain dollar value and it has a certain amount of mileage on it. In reality, a class may have an infinite number of attributes because you can describe the car in many different ways. But not all those attributes are probably relevant in defining a class anyway.</p>

<p><img src="http://i.imgur.com/3rdOboN.png" alt="enter image description here"></p>

<p>A class may have <em>methods</em>. Methods are associated with actions done by objects. For example, a car accelerating and decelerating may be methods of objects.</p>

<h3>Creating A Class</h3>

<p>Use <code>class</code> keyword to create classes in Ruby.</p>

<pre lang="ruby"><code>class Car
end
</code></pre>

<p>The class name must be start with a capital letter. <code>self</code> refers to the class, if <code>self</code> is mentioned in the body of a class, but it is not referring to the instance methods in the class.</p>

<h3>Instantiation and Initialization</h3>

<p><em>Instantiation</em> is creating an object of a certain <em>type</em> from a class. The class is what determines the type of an object. For example, A <em>Civic</em> is a <em>Car</em> typed object created through <em>instantiation</em> from the <em>Car</em> class.</p>

<p>Initialization is the process that gives values to attributes of an instantiated object. It could be said that a Civic has <em>1800</em> cc for the <em>engine</em> attribute and <em>140</em> for the <em>horse power</em> attribute.</p>

<p>Instantiation is done with the class method called <code>initialize</code>. But here is the confusing part. When you want to invoke the <code>initialize</code> method, you invoke it by calling <code>new</code> instead. Normally, when you invoke a method, you call it with the same method&#39;s name. To make the confusion even worse, you don&#39;t need to explicitly write an <code>initialize</code> method in the class to invoke it using <code>new</code>. The code below will run without any error.</p>

<pre lang="ruby"><code>class Car
end

my_new_car = Car.new
</code></pre>

<p>Initialization of an object may or may not happen during the instantiation. If the initialization of an object is done during instantiation, the attributes are initialized with some value by passing arguments to the <code>new</code> method. Initialization through instantiation requires you to write an <code>initialize</code> method in the class. You also need to write methods for the attributes of the class.</p>

<h3>Attributes</h3>

<p>Attributes are relevant qualities that describe a class. A car class has numerous relevant qualities that describe up a car. Let&#39;s say the only qualities we are interested in are the manufacturer&#39;s name, the car&#39;s name, its engine and horse power rating. Then the car class can be written like this.</p>

<pre lang="ruby"><code>class Car
  attr_accessor :manufacturer, :car_name, :engine, :horse_power
end
</code></pre>

<p>In this example, <code>attr_accessor</code> is a method that defines the attributes of this class for you. In the example above, we created attributes called <em>manufacturer</em>, <em>car_name</em>, <em>engine</em>, and <em>horse_power</em>. By creating attributes with <code>attr_accessor</code>, you can <em>set</em> values to attributes and <em>get</em> values from attributes.</p>

<pre lang="ruby"><code>class Car
  attr_accessor :manufacturer, :car_name, :engine, :horse_power
end

# instantiation
civic = Car.new

# setting values to attributes
civic.car_name = &quot;Civic&quot;
civic.manufacturer = &quot;Honda&quot;
civic.engine = 1800
civic.horse_power = 140

# getting values from attributes
puts civic.car_name
puts civic.manufacturer
puts civic.engine
puts civic.horse_power
</code></pre>

<p>The <code>attr_accessor</code> method is actually a shorter way of writing setter and getter method yourself. The example above could&#39;ve been written with many more setter and getter methods like below.</p>

<pre lang="ruby"><code>class Car
  #setters
  def manufacturer=(value)
    @manufacturer = value
  end

  def car_name=(value)
    @car_name = value
  end

  def engine=(value)
    @engine = value
  end

  def horse_power=(value)
    @horse_power = value
  end

  #getters
  def manufacturer
    @manufacturer
  end

  def car_name
    @car_name
  end

  def engine
    @engine
  end

  def horse_power
    @horse_power
  end
end

# instantiation
civic = Car.new

# setting values to attributes
civic.car_name = &quot;Civic&quot;
civic.manufacturer = &quot;Honda&quot;
civic.engine = 1800
civic.horse_power = 140

# getting values from attributes
puts civic.car_name
puts civic.manufacturer
puts civic.engine
puts civic.horse_power
</code></pre>

<p>Hopefully, getters and setters written like the code above indicates how getters and setters work in Ruby. Attributes are just methods that assign values to class variables and get values of class variables. Class variables are the variables that start with <code>@</code>. Don&#39;t write setters and getters unless you feel that there is a compelling reason to do so. Simply use the <code>attr_accessor</code> method to write attributes for a class.</p>

<p>Setting the values of attributes one by one can be tedious when a class has many attributes. In such cases, you can write the <code>initialize</code> method that takes a hash of attributes and values as arguments.</p>

<pre lang="ruby"><code>class Car
  attr_accessor :manufacturer, :car_name, :engine, :horse_power

  def initialize(hash)
    @manufacturer = hash[:manufacturer]
    @car_name = hash[:car_name]
    @engine = hash[:engine]
    @horse_power = hash[:horse_power]
  end
end

civic = Car.new({
  :manufacturer =&gt; &quot;Honda&quot;,
  :car_name =&gt; &quot;Civic&quot;,
  :engine =&gt; &quot;1800&quot;,
  :horse_power =&gt; &quot;140&quot;
})

puts civic.car_name
puts civic.manufacturer
puts civic.engine
puts civic.horse_power
</code></pre>

<h3>Methods in Classes</h3>

<p>Classes have methods. Some methods for a class exist simply by creating a class. For example, the class method <code>name</code> exists for all classes even though you don&#39;t explicitly write the method.</p>

<pre lang="ruby"><code>class Car
end

Car.name
</code></pre>

<p>There is actually a class method that returns an array of class methods available to the class by simply being created.</p>

<pre lang="ruby"><code>class Car
end

Car.methods
</code></pre>

<p>A class can contain two kinds of methods. They are instance methods and class methods. Instance methods for a class are applied to instances of the same type. Class methods are applied to its class.</p>

<h4>Instance Methods</h4>

<p>Instance methods are methods that are invoked for instances of the class. Like other methods, the method is applied with the <code>.</code> operator.</p>

<pre lang="ruby"><code>class Car
  attr_accessor :manufacturer, :car_name, :engine, :horse_power

  def initialize(hash)
    @manufacturer = hash[:manufacturer]
    @car_name = hash[:car_name]
    @engine = hash[:engine]
    @horse_power = hash[:horse_power]
  end

  def to_print
    puts &quot;Manufacturer: #{self.manufacturer}&quot;
    puts &quot;Name: #{self.car_name}&quot;
    puts &quot;Engine: #{self.engine}&quot;
    puts &quot;Horse pwer: #{self.horse_power}&quot;
  end
end

civic = Car.new({
  :manufacturer =&gt; &quot;Honda&quot;,
  :car_name =&gt; &quot;Civic&quot;,
  :engine =&gt; &quot;1800&quot;,
  :horse_power =&gt; &quot;140&quot;
})

civic.to_print
</code></pre>

<p>The Car class contains a <code>to_print</code> method. The <code>to_print</code> method is an instance method that Car objects can use to print values of attributes. To use the <code>to_print</code> method, we prepare a Car object, <code>civic</code>. Then we apply the <code>to_print</code> method onto <code>civic</code> with the <code>.</code> operator. As a result, the <code>to_print</code> method prints the attributes of <code>civic</code>.</p>

<h5><code>self</code></h5>

<p>We have seen <code>self</code> several times. Now we are equipped to talk about <code>self</code>. <code>self</code> has two use cases.</p>

<p>First, <code>self</code> refers to the object that the method is invoked on. The object here may refer to an object instance, a class, or a module and return value of a method.</p>

<p>The <code>to_print</code> method makes use of <code>self</code> to refer to the object the method is invoked on. In this case, <code>self</code> refers to <code>civic</code> in this case.</p>

<p>Second, <code>self</code> can also be used to denote that a method contained in a class is a <em>class method</em>.</p>

<h4>Class Methods</h4>

<p>Class methods are methods that are called onto classes. The <code>.</code> operator is used to invoke the method on the class like other methods.</p>

<p>Class methods are defined in a class with <code>self</code>. Class methods take the form of <code>self.method_name</code>.</p>

<pre lang="ruby"><code>class Car
  def self.manufacturer_list
    %w{Audi BMW Buick Cadillac Chevrolet Chrysler Dodge Ferrari
       Ford GM GEM GMC Honda Hummer Hyundai Infiniti Isuzu Jaguar
       Jeep Kia Lamborghini Land Rover Lexus Lincoln Lotus Mazda
       Mercedes-Benz Mercury Mitsubishi Nissan Oldsmobile Peugeot
       Pontiac Porsche Regal Saab Saturn Subaru Suzuki Toyota
       Volkswagen Volvo}
  end
end

Car.manufacturer_list
</code></pre>

<p>The <code>manufacturer_list</code> method is a class method that returns an array of car manufacturers. The method is called stating the class <code>Car</code> and then using the operator <code>.</code>.</p>

<p><code>%w{words}</code> returns an array of strings for words split by a space.</p>

<h3>Inheritance</h3>

<p>Classes can have relationships with other classes. Say we had a Sedan class.</p>

<pre lang="ruby"><code>class Sedan
end
</code></pre>

<p>Sedans are a subset of cars. Therefore, when we relate the Car class and the Sedan class, we say, &quot;Sedan class <em>inherits from</em> Car class&quot; or &quot;Sedan class <em>extends</em> Car class&quot;. The Car class is a <em>superclass</em> or a <em>parent class</em> and the Sedan class is a <em>subclass</em> or a <em>child class</em>.</p>

<p>A class may have many subclasses, but it can only belong to superclass. <em>Descendants</em> of a superclass are subclasses that are <em>children</em> to the superclass. <em>Ancestors</em> of a subclass are any classes that have the subclass as a child.</p>

<pre lang="ruby"><code>class Car
end

class Sedan &lt; Car
end
</code></pre>

<h4>Methods in Superclasses and Subclasses</h4>

<p>A subclass inherits methods from its superclass.</p>

<pre lang="ruby"><code>class Car
  def vroom
    &quot;vroom vroom&quot;
  end
end

class Sedan &lt; Car
end

civic = Sedan.new
civic.vroom
</code></pre>

<p>Notice that Sedan class doesn&#39;t have a method called <code>vroom</code> in the example above. However, the Sedan object, <code>civic</code> still is able to invoke the <code>vroom</code> method because the Sedan class inherits from the Car class. As a result <code>civic.vroom</code> returns &quot;vroom vroom&quot;.</p>

<p>What happens if the Sedan class also has a method called <code>vroom</code>, but does something different?</p>

<pre lang="ruby"><code>class Car
  def vroom
    &quot;vroom vroom&quot;
  end
end

class Sedan &lt; Car
  def vroom
    &quot;vvvvrooom vroom vroom&quot;
  end
end

civic = Sedan.new
civic.vroom
</code></pre>

<p>Because <code>civic</code> is a Sedan object, it looks for the instance method in the Sedan class first-before any superclass. The Sedan class has an instance method called <code>vroom</code>, so <code>civic.vroom</code> returns <code>&quot;vvvvrooom vroom vroom&quot;</code>. When a subclass&#39;s method name is same as its superclass&#39;s method, the subclass&#39;s method is said to <em>override</em> the superclass&#39;s method.</p>

<h3>Method Availability</h3>

<p>Instance methods are either <em>public</em>, <em>private</em>, or <em>protected</em>. The three kinds of methods define the availability of methods in the program.</p>

<p>Methods are public by default. When a method is public, it can be used outside the class freely.</p>

<pre lang="ruby"><code>class Car
  def vroom
    &quot;vroom vroom&quot;
  end
end

class Unrelated
  def car_vroom
    car = Car.new
    car.vroom
  end
end

unrelated = Unrelated.new
unrelated.car_vroom
</code></pre>

<p>We have a class called Unrelated that is entirely unrelated to the Car class. Yet because <code>vroom</code> method in the Car class is public, it can be used inside another class&#39;s method. In this case, the <code>car_vroom</code> method inside Unrelated is freely using <code>vroom</code> method of Car class.</p>

<p>Private methods are only available to other instance methods in the class and instance methods in the subclasses. Protected methods are available to other instance methods in the class and instance methods in the subclasses too-like private methods. The difference between protected methods and private methods is the object that the instance methods are invoked on. Private instance methods are invoked implicitly on the <code>self</code>. Protected instance methods are invoked on any instance of the class.</p>

<pre lang="ruby"><code>class Car
  protected
    def crunk
      &quot;crunk&quot;
    end
end

class Sedan &lt; Car
  def car_crunk
    car = Car.new
    car.crunk
  end

  def sedan_crunk
    self.crunk
  end
end

class Unrelated
  def car_crunk
    car = Car.new
    car.crunk
  end
end

car = Car.new
car.crunk # NoMethodError: protected method `crunk&#39; called for ...

sedan = Sedan.new
sedan.car_crunk
sedan.sedan_crunk

unrelated = Unrelated.new
unrelated.car_crunk # NoMethodError: protected method `crunk&#39; called for ...
</code></pre>

<p>The example above illustrates the available scope of protected method. First, the car instance outside the class cannot call <code>crunk</code> because it&#39;s a protected method. However, you can call the <code>crunk</code> method on the car instance, when the instance is inside the Sedan class because the Sedan class is a subclass of the Car class. Lastly the unrelated instance cannot make use of the <code>crunk</code> method because the Unrelated class does not inherit it from the Car class.</p>

<pre lang="ruby"><code>class Car
  private
    def flunk
      &quot;flunk&quot;
    end
end

class Sedan &lt; Car
  def car_flunk
    car = Car.new
    car.flunk
  end

  def sedan_flunk
    self.flunk
  end
end

class Unrelated
  def car_flunk
    car = Car.new
    car.flunk
  end
end

car = Car.new
car.flunk # NoMethodError: private method `flunk&#39; called for ...

sedan = Sedan.new
sedan.car_flunk # NoMethodError: private method `flunk&#39; called for ...
sedan.sedan_flunk # NoMethodError: private method `flunk&#39; called for ...

unrelated = Unrelated.new
unrelated.car_flunk # NoMethodError: private method `flunk&#39; called for
</code></pre>

<p>The code above illustrates the private method availability in different cases. Notice that whenever the private method, <code>crunk</code> was used outside the class itself, and the subclass, Sedan, a NoMethodError was thrown.</p>

<p>As a rule of thumb, public methods are written first in the class, then comes protected methods followed finally by the private methods inside a class.</p>

<pre lang="ruby"><code>class Car
  #public methods

  #protected methods
  protected

  #private methods
  private
end
</code></pre>

<h3>Modules</h3>

<p>Modules are like classes except for the fact that modules cannot create objects through instantiation whereas classes can. Modules also lack the ability to inherit from or inherit to other modules unlike classes. Modules are written with a keyword, <code>module</code>. And the module name followed by the keyword <code>module</code> must start with a capital letter.</p>

<pre lang="ruby"><code>module Human
end
</code></pre>

<p>Modules are used as a namespace for related methods and classes.</p>

<pre lang="ruby"><code>module Human
  # using self
  def self.genders
    [&quot;male&quot;, &quot;female&quot;]
  end

  # using moduel name
  def Human.ubermensch
    &quot;programmers&quot;
  end

  class Male
    def origin
      &quot;Mars&quot;
    end
  end

  class Female
    def origin
      &quot;Venus&quot;
    end
  end
end

Human.genders
Human.ubermensch
man = Male.new  # this will not work
woman = Female.new  # this will not work either

man = Human::Male.new
woman = Human::Female.new
man.origin
woman.origin
</code></pre>

<p>Modules have module methods that are similar to the way class methods work. Module methods are written by prefixing <code>self</code> or the module name <code>ModuleName</code>. There is no difference between the two ways of writing the module methods.</p>

<p>When you refer to a class inside a module, you must prefix it with the <code>ModuleName</code> and double colons <code>::</code>.</p>

<h2>Copyright</h2>

<p>copyright Jason Kim, 2013</p>


      </div>
    </div>
  </div>
</body>
</html>
